
--[[
Start off with a definition for unicode glyph slot names.
These need to be consistent because they're used programmatically.
Note that we could have defined this in a more "nested"-like structure,
but this would have made it less clear that we're talking about input
and output characters here, not abstractions.
--]]

require('umath-glyph-names.lua')

latin_upper = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}
latin_lower = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}

greek_upper = {'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta',
  'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau',
  'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'}
greek_lower = {'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta',
  'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau',
  'upsilon', 'phi', 'chi', 'psi', 'omega'}

greek_sym = {'varTheta','nabla','partial','varsigma','vartheta','varpi','varkappa','varrho','varepsilon'}

num = {'zero','one','two','three','four','five','six','seven','eight','nine'}

--[[

# Define the mappings

Basically what we want here is to end up with a nested table structure that looks like

math_map = {
  ["italic"] = { ["mrmA"] = "mitA" , ["mrmB"] = "mrmB" , ... }
  ["bold"]   = { ["mrmA"] = "mbfA" , ["mrmB"] = "mbfB" , ... }
}

So to do this we define:

 * What the "name" of the math alphabet is ("italic", "bold", ...) (this is loop 1)
 * What the "prefix" of it is ("mit", "mbf")
 * What alphabets need to be included (this is loop 2)

Each alphabet is defined in terms of a series of slot names (this is loop 3).

This setup makes things nice and general, and we can define arbitrary alphabets as long as the
glyph naming scheme is consistent. If the glyph names are NOT consistent, we need to augment
the resulting structure manually. This is probably easier than making the construction code
any more convoluted!

--]]

mathalph = {}
mathalph.italic         = { ["prefix"] = "mit" ,       ["alphlist"] = {latin_upper,latin_lower,greek_upper,greek_lower,greek_sym} }
mathalph.bold           = { ["prefix"] = "mbf" ,       ["alphlist"] = {latin_upper,latin_lower,greek_upper,greek_lower,greek_sym,num} }
mathalph.bolditalic     = { ["prefix"] = "mbfit" ,     ["alphlist"] = {latin_upper,latin_lower,greek_upper,greek_lower,greek_sym} }
mathalph.scr            = { ["prefix"] = "mscr" ,      ["alphlist"] = {latin_upper,latin_lower} }
mathalph.boldscr        = { ["prefix"] = "mbfscr" ,    ["alphlist"] = {latin_upper,latin_lower} }
mathalph.frak           = { ["prefix"] = "mfrak" ,     ["alphlist"] = {latin_upper,latin_lower} }
mathalph.boldfrak       = { ["prefix"] = "mbffrak" ,   ["alphlist"] = {latin_upper,latin_lower} }
mathalph.bb             = { ["prefix"] = "Bbb" ,       ["alphlist"] = {latin_upper,latin_lower,num} }
mathalph.tt             = { ["prefix"] = "mtt" ,       ["alphlist"] = {latin_upper,latin_lower,num} }
mathalph.sans           = { ["prefix"] = "msans" ,     ["alphlist"] = {latin_upper,latin_lower,num} }
mathalph.sansitalic     = { ["prefix"] = "mitsans" ,   ["alphlist"] = {latin_upper,latin_lower} }
mathalph.boldsans       = { ["prefix"] = "mbfsans" ,   ["alphlist"] = {latin_upper,latin_lower,greek_upper,greek_lower,greek_sym,num} }
mathalph.boldsansitalic = { ["prefix"] = "mbfitsans" , ["alphlist"] = {latin_upper,latin_lower,greek_upper,greek_lower,greek_sym} }

math_map = {}
input_prefix = 'mrm'

for mathalph_name,thismathalph in pairs(mathalph) do
  math_map[mathalph_name] = {}
  for i,alphlist in pairs(thismathalph.alphlist) do
    for ii,slotname in pairs(alphlist) do
      math_map[mathalph_name][input_prefix..slotname] = thismathalph.prefix..slotname
    end
  end
end


--[[

# Write the tables to file in appropriate ways

Three files needed:

1. The Lua table mapping numeric glyph slots to glyph slots for each math alphabet.
   Basically a slimmed down `serialise`.

2. The XeTeX font mapping files.

3. For convenience, a shell script for compiling the XeTeX font mapping files so XeTeX can read them.

--]]

local f = assert(io.open("umath-alphabet-mappings.lua", "w"))
f:write("-- this file is automatically generated; do not edit","\n\n")
f:write("math_maps = {","\n")
for kk,vv in pairs(math_map) do
  f:write("  [\"",kk,"\"] = {","\n")
  for k,v in pairs(vv) do
    slot = math_sym_names[k] or k
    val  = math_sym_names[v] or v
    f:write("    [0x",slot,"] = 0x",val," ,","\n")
  end
  f:write("  },","\n")
end
f:write('}','\n')
f:close()

teckit_prefix = "mapping_math_"
for kk,vv in pairs(math_map) do
  local f = assert(io.open(teckit_prefix..kk..".map", "w"))
  f:write("LHSName \"ascii\"","\n","RHSName \"","unicode-maths-",kk,"\"","\n","pass(Unicode)","\n\n")
  for k,v in pairs(vv) do
    slot = math_sym_names[k] or k
    val  = math_sym_names[v] or v
    f:write("U+",slot," <> U+",val," ;\n")
  end
  f:close()
end

local f = assert(io.open("teckit_compile_mappings.sh", "w"))
f:write("#!/bin/sh","\n\n")
for kk,vv in pairs(math_map) do
  f:write("teckit_compile ",teckit_prefix,kk,"\n")
end
f:close()
